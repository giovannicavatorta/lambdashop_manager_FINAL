{"ast":null,"code":"import axios from \"axios\";\n\nclass AuthenticatorService {\n  constructor() {\n    this.state = {\n      serverURL: \"http://localhost:5071/api\"\n    };\n\n    this.getBAuthHeader = (user, psw) => {\n      return \"Basic \" + window.btoa(user + \":\" + psw);\n    };\n\n    this.authenticateUser = (user, psw) => {\n      return axios.get(`${this.state.serverURL}/gifts/auth`, {\n        // Aggiungo nell'header le specifiche di autenticazione\n        // ottenute tramite la lambda preposta\n        headers: {\n          authorization: this.getBAuthHeader(user, psw)\n        }\n      });\n    };\n\n    this.setUserInformations = (user, psw) => {\n      // Salvo nel session storage [Parametri: nome(str), params(funzione)]\n      sessionStorage.setItem(\"user\", user); // Richiamo l'interceptor per gli header di basicauth\n\n      this.setupAxiosInterceptors(this.getBAuthHeader(user, psw));\n    };\n\n    this.getUserInformations = () => {\n      return sessionStorage.getItem(\"user\");\n    };\n\n    this.clearUserInformations = () => {\n      sessionStorage.removeItem(\"user\");\n    };\n\n    this.isLoggedIn = () => {\n      let user = this.getUserInformations(); // Strict check\n\n      if (user === null) return false;else return true;\n    };\n  }\n\n  // Creo un metodo di axios (interceptor) che genera un \n  // BasicAuthHeader (come commentato \"old\" hard-coded nelle API).\n  // Lo richiamo nel momento stesso in cui vado a salvare le info dell'utente nel session storage,\n  // quindi in setUserInformations\n  // https://axios-http.com/docs/interceptors\n  // Non funziona del tutto correttamente: L'header non viene aggiornato, mantiene i dati dell'utente precedente...\n  // FIX \"BRUTTO\" --> Si potrebbe commentare e settare \"a mano\" l'header per ogni chiamata ai servizi...\n  // Non sarebbe però scalabile\n  setupAxiosInterceptors(BAuthHeader) {\n    axios.interceptors.request.use(config => {\n      // Verifico che l'utente si loggato per creare l'interceptor...\n      if (this.isLoggedIn()) {\n        config.headers.authorization = BAuthHeader;\n      }\n\n      return config;\n    });\n  }\n\n}\n\nexport default new AuthenticatorService();","map":{"version":3,"names":["axios","AuthenticatorService","state","serverURL","getBAuthHeader","user","psw","window","btoa","authenticateUser","get","headers","authorization","setUserInformations","sessionStorage","setItem","setupAxiosInterceptors","getUserInformations","getItem","clearUserInformations","removeItem","isLoggedIn","BAuthHeader","interceptors","request","use","config"],"sources":["/Users/cwgio97/Documents/React/lambdashop_manager/src/components/services/authservice.js"],"sourcesContent":["import axios from \"axios\";\n\nclass AuthenticatorService {\n\n    // Creo uno state con user e psw hardcoded (temp per test))\n    /*\n    state = {\n        user: \"admin\",\n        psw: \"admin\"\n    }\n    */\n\n    // Gestisco l'autenticazione interfacciandomi con il backend\n    state = {\n        serverURL: \"http://localhost:5071/api\"\n    }\n\n    // Definisco una funzione che mi ritorni la stringa corretta per la BasicAuth,\n    // da inserire nell'header delle richieste.\n    getBAuthHeader = (user, psw) => {\n        return \"Basic \" + window.btoa(user + \":\" + psw);\n    }\n\n    // Ottengo la stringa OK da backend (se i dati sono corretti - altrimenti: 401)\n    // inserendo nell'header della richiesta i dati di login\n    authenticateUser = (user, psw) => {\n        return axios.get(`${this.state.serverURL}/gifts/auth`,\n        {\n            // Aggiungo nell'header le specifiche di autenticazione\n            // ottenute tramite la lambda preposta\n            headers: {authorization: this.getBAuthHeader(user, psw)}\n        });\n    }\n\n    // Metodo di salvataggio nel session storage\n    setUserInformations = (user, psw) => {\n        // Salvo nel session storage [Parametri: nome(str), params(funzione)]\n        sessionStorage.setItem(\"user\", user);\n        // Richiamo l'interceptor per gli header di basicauth\n        this.setupAxiosInterceptors(this.getBAuthHeader(user, psw));\n    }\n\n    // Ottengo info utente (nome da mostrare a video)\n    getUserInformations = () => {\n        return sessionStorage.getItem(\"user\");\n    }\n\n    // Metodo di rimozione info utente dal session storage\n    clearUserInformations = () => {\n        sessionStorage.removeItem(\"user\");\n    }\n\n    // BOOL: controllo se l'utente è loggato\n    isLoggedIn = () => {\n        let user = this.getUserInformations();\n        // Strict check\n        if (user === null) return false;\n        else return true;\n    }\n\n    // Creo un metodo di axios (interceptor) che genera un \n    // BasicAuthHeader (come commentato \"old\" hard-coded nelle API).\n    // Lo richiamo nel momento stesso in cui vado a salvare le info dell'utente nel session storage,\n    // quindi in setUserInformations\n    // https://axios-http.com/docs/interceptors\n    // Non funziona del tutto correttamente: L'header non viene aggiornato, mantiene i dati dell'utente precedente...\n    // FIX \"BRUTTO\" --> Si potrebbe commentare e settare \"a mano\" l'header per ogni chiamata ai servizi...\n    // Non sarebbe però scalabile\n    setupAxiosInterceptors(BAuthHeader) {\n        axios.interceptors.request.use(\n            (config) => {\n                // Verifico che l'utente si loggato per creare l'interceptor...\n                if (this.isLoggedIn()) {\n                    config.headers.authorization = BAuthHeader\n                }\n                return config;\n            }\n        )\n    }\n}\n\nexport default new AuthenticatorService();"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;;AAEA,MAAMC,oBAAN,CAA2B;EAAA;IAAA,KAWvBC,KAXuB,GAWf;MACJC,SAAS,EAAE;IADP,CAXe;;IAAA,KAiBvBC,cAjBuB,GAiBN,CAACC,IAAD,EAAOC,GAAP,KAAe;MAC5B,OAAO,WAAWC,MAAM,CAACC,IAAP,CAAYH,IAAI,GAAG,GAAP,GAAaC,GAAzB,CAAlB;IACH,CAnBsB;;IAAA,KAuBvBG,gBAvBuB,GAuBJ,CAACJ,IAAD,EAAOC,GAAP,KAAe;MAC9B,OAAON,KAAK,CAACU,GAAN,CAAW,GAAE,KAAKR,KAAL,CAAWC,SAAU,aAAlC,EACP;QACI;QACA;QACAQ,OAAO,EAAE;UAACC,aAAa,EAAE,KAAKR,cAAL,CAAoBC,IAApB,EAA0BC,GAA1B;QAAhB;MAHb,CADO,CAAP;IAMH,CA9BsB;;IAAA,KAiCvBO,mBAjCuB,GAiCD,CAACR,IAAD,EAAOC,GAAP,KAAe;MACjC;MACAQ,cAAc,CAACC,OAAf,CAAuB,MAAvB,EAA+BV,IAA/B,EAFiC,CAGjC;;MACA,KAAKW,sBAAL,CAA4B,KAAKZ,cAAL,CAAoBC,IAApB,EAA0BC,GAA1B,CAA5B;IACH,CAtCsB;;IAAA,KAyCvBW,mBAzCuB,GAyCD,MAAM;MACxB,OAAOH,cAAc,CAACI,OAAf,CAAuB,MAAvB,CAAP;IACH,CA3CsB;;IAAA,KA8CvBC,qBA9CuB,GA8CC,MAAM;MAC1BL,cAAc,CAACM,UAAf,CAA0B,MAA1B;IACH,CAhDsB;;IAAA,KAmDvBC,UAnDuB,GAmDV,MAAM;MACf,IAAIhB,IAAI,GAAG,KAAKY,mBAAL,EAAX,CADe,CAEf;;MACA,IAAIZ,IAAI,KAAK,IAAb,EAAmB,OAAO,KAAP,CAAnB,KACK,OAAO,IAAP;IACR,CAxDsB;EAAA;;EA0DvB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAW,sBAAsB,CAACM,WAAD,EAAc;IAChCtB,KAAK,CAACuB,YAAN,CAAmBC,OAAnB,CAA2BC,GAA3B,CACKC,MAAD,IAAY;MACR;MACA,IAAI,KAAKL,UAAL,EAAJ,EAAuB;QACnBK,MAAM,CAACf,OAAP,CAAeC,aAAf,GAA+BU,WAA/B;MACH;;MACD,OAAOI,MAAP;IACH,CAPL;EASH;;AA5EsB;;AA+E3B,eAAe,IAAIzB,oBAAJ,EAAf"},"metadata":{},"sourceType":"module"}